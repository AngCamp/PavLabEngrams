---
title: "Reproducing Chen et al., (2020)"
author: "Angus Campbell"
date: "25/01/2022"
output: html_document
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "C:/Users/angus/Desktop/PavLabEngrams/EngramCellClassifier")
getwd()
```



```{r include=FALSE}
setwd("C:/Users/angus/Desktop/PavLabEngrams/EngramCellClassifier")
library(tidyverse)
library(GEOquery)
library(AnnotationDbi)
library(randomForest)
library(data.table)
library(reshape2)
library(FactoMineR)
library(factoextra)
library(Rtsne)
library(dplyr)
library(Seurat)
library(stringr)
```


```{r}
chen2020_counts <- read.csv('Chen2020_GSE152632/GSE152632_GEO_mberkchen_TRAP2_counts.csv.gz', header = TRUE)
rownames(chen2020_counts) <- chen2020_counts$X
chen2020_counts <- chen2020_counts[,2:3531]
chen2020_meta <- read.csv( 'Chen2020_GSE152632/SraRunTable.txt', header = TRUE)

chen2020_meta$engram_label <-  as.factor(sapply(as.character(colnames(chen2020_counts)), function(y) if (grepl("_pos_", y, fixed=TRUE)) "tdT+" else "tdT-"))

condition_label <- chen2020_meta$source_name %>%
  sapply( function(y) if (grepl("Homecage", y, fixed=TRUE)) "Homecage")

condition_label <- chen2020_meta$source_name
condition_label[str_detect(condition_label, "Homecage")] = "Homecage"
condition_label[str_detect(condition_label, "Context-Only")] = "Context-Only"
condition_label[str_detect(condition_label, "Fear-Only")] = "Fear-Only"
condition_label[str_detect(condition_label, "Fear-Recall")] = "Fear-Recall"
chen2020_meta$condition_label <- condition_label
rm(condition_label)

condition_label <- as.character(sapply(condition_label, function(y) if (grepl("Homecage", y, fixed=TRUE)) "Homecage"))
condition_label <- sapply(rownames(condition_label), function(y) if (grepl("Context-Only", y, fixed=TRUE)) "Context-Only")
#one row is missing in the metadata
```

## From Methods - Bioinformatics and data analysis - Mapping to the genome
"Sequences from Nextseq or Novaseq were demultiplexed using bcl2fastq, and reads were aligned to the mm10 genome augmented with ERCC (External RNA Controls Consortium) sequences, using STAR version 2.5.2b. Gene counts were made using HTSEQ version 0.6.1p1. All packages were called and run through a custom Snakemake pipeline. We applied standard algorithms for cell filtration, feature selection and dimensionality reduction. Briefly, genes that appeared in fewer than five cells, samples with fewer than 100 genes and samples with less than 50,000 reads were excluded from the analysis. Out of these cells, those with more than 30% of reads as ERCC, and more than 10% mitochondrial or 10% ribosomal were also excluded from analysis. Counts were log-normalized and then scaled where appropriate.

Next, the ‘canonical correlation analysis’ function from the Seurat package27 was used to align raw data from multiple experiments. Only the first ten canonical components were used. After alignment, relevant features were selected by filtering expressed genes to a set of ~2,500 with the highest positive and negative pairwise correlations. Genes were then projected into principal component space using the robust principal component analysis. Single-cell principal component scores and gene loadings for the first 20 principal components were used as inputs into Seurat’s (v2) FindClusters and RunTsne functions to calculate 2D tSNE coordinates and search for distinct cell populations. Briefly, a shared-nearest-neighbour graph was constructed based on the Euclidean distance metric in the principal component space, and cells were clustered using the Louvain method. Cells and clusters were then visualized using 3D tSNE embedding on the same distance metric. A neuron was characterized as ‘TRAPed’ trapped if it satisfied two conditions: (1) from the tdT + sort gate (tdT protein positive) and (2) tdT mRNA raw count > 0. Neuron subtype marker genes were found by using the FindAllMarkers function in Seurat (min.pct = 0.3, thresh.use = 0.25, min.diff.pct = 0.2). DEG analysis was done by applying the Mann–Whitney U-test on various cell populations. Raw P values were adjusted to an FDR. Permutation tests were then performed on all genes of interest. All graphs and analyses were generated and performed in R. GeneAnalytics and GeneCards packages offered by the gene set enrichment analysis tool were used for GO/KEGG/REACTOME pathway analysis and classification of enriched genes in each subpopulation."


```{r}
# We can skip the alignment as we have the raw counts, so we can start at
# Check for some of their filters to see if those have already been done
# Are there any gene's that appear in fewer than five cells?

underexpressedgenes <- which(table(which(chen2020_counts == 0, arr.ind = TRUE)[,1])>(3530-5))
```
So above I have identified 141 genes which do not appear in more than 5 cells which means we will need to do some filtering.
They do not provide information.

```{r}
# samples with less than 100 genes to be excluded
# all pass this filter
print("Number of cells with more than 100 gene's expressed...")
print(sum(colSums(chen2020_counts>1)>100))

#samples with less than 50 000 reads to be excluded, all cells pass this threshold
print("Cells with less than 50 000 reads...")
print(sum(colSums(chen2020_counts)<50000))
```
So all cells pass those filters.  Not sure how to do the ERCC, mitochondrial and ribosomal gene check, presumably this explains the missing cells.
I am guessing they left in unfiltered gene's but they excluded cells not passing threshold.  

Integrating different experiments with suerat is described [here](https://satijalab.org/seurat/articles/integration_introduction.html).  We will need to do something like this to compare the homecage, fear, and 

Attempt to do the anlysis according to Seurat.  Present paul with some data, also have a look at Fernandez tomorrow.  I will download it overnight.
```{r}
# attempting to replicate their description of how they chose gene's to include
# I'm going to exclude the under expressed gene's

chen2020_counts <- chen2020_counts[!c(1:23355) %in% underexpressedgenes,]
rownames(chen2020_meta) <- colnames(chen2020_counts)

tdTpos.idx <- which(chen2020_meta$engram_label=="tdT+")
tdTneg.idx <- which(chen2020_meta$engram_label=="tdT-")

#library(Seurat)
chen2020 <- CreateSeuratObject(counts = chen2020_counts)
                               #meta.data = chen2020_meta)

chen2020 <- FindVariableFeatures(chen2020, selection.method = "vst", nfeatures = 3530) #no idea how I chose 3530, 
# in the tutorial they chose 2000, I just chose to match the number of cells we had
chen2020nobatch <- ScaleData(chen2020)

chen2020 <- AddMetaData(chen2020, chen2020_meta)

test = RunPCA(chen2020nobatch, features = VariableFeatures(chen2020))

#https://broadinstitute.github.io/2019_scWorkshop/correcting-batch-effects.html

# seurat tutorial
# https://yu-tong-wang.github.io/talk/sc_st_data_analysis_R.html
# has spatial transcritomics data as well 
# the whole github is really great

batch.list <- unique(chen2020_meta$source_name)
obj.list <- c()
for (i in batch.list){
  maus <- which(chen2020_meta$source_name==batch.list[i])
  obj.list <- c(obj.list, subset(chen2020, cells = colnames(chen2020)[maus]))
}

gcdata.CCA <- RunMultiCCA(ob.list, genes.use = genes.use, num.ccs = 20) #
# 
# ob.list <- list(celseq, celseq2, fluidigmc1, smartseq2)
# genes.use <- c()
# for (i in 1:length(ob.list)) {
#   genes.use <- c(genes.use, head(rownames(ob.list[[i]]@hvg.info), 1000))
# }
# genes.use <- names(which(table(genes.use) > 1))
# for (i in 1:length(ob.list)) {
#   genes.use <- genes.use[genes.use %in% rownames(ob.list[[i]]@scale.data)]
# }

# Run multi-set CCA on the 4 pancreatic islet datasets. 
# Use the variable genes above, and calculate 15 canonical components.




engram.cells <- subset(chen2020, cells = colnames(chen2020)[tdTpos.idx])
nonengram.cells <- subset(chen2020, cells = colnames(chen2020)[tdTneg.idx])
engram.cells[["group"]] <- "group1"
nonengram.cells[["group"]] <- "group2"


chenCCA <- RunCCA(object1 = engram.cells, object2 = nonengram.cells,
                  features = TRUE)

,
                  compute.gene.loadings = TRUE)

```
https://satijalab.org/seurat/reference/findintegrationanchors
-could possibly use this function for all conditions
